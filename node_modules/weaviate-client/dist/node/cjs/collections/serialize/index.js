'use strict';
Object.defineProperty(exports, '__esModule', { value: true });
exports.Serialize = exports.MetadataGuards = exports.DataGuards = void 0;
const uuid_1 = require('uuid');
const batch_js_1 = require('../../proto/v1/batch.js');
const search_get_js_1 = require('../../proto/v1/search_get.js');
const errors_js_1 = require('../../errors.js');
const base_js_1 = require('../../proto/v1/base.js');
const classes_js_1 = require('../filters/classes.js');
const index_js_1 = require('../filters/index.js');
const classes_js_2 = require('../references/classes.js');
const utils_js_1 = require('../references/utils.js');
class FilterGuards {}
FilterGuards.isFilters = (argument) => {
  return argument instanceof index_js_1.Filters;
};
FilterGuards.isText = (argument) => {
  return typeof argument === 'string';
};
FilterGuards.isTextArray = (argument) => {
  return argument instanceof Array && argument.every((arg) => typeof arg === 'string');
};
FilterGuards.isInt = (argument) => {
  return typeof argument === 'number' && Number.isInteger(argument);
};
FilterGuards.isIntArray = (argument) => {
  return (
    argument instanceof Array && argument.every((arg) => typeof arg === 'number' && Number.isInteger(arg))
  );
};
FilterGuards.isFloat = (argument) => {
  return typeof argument === 'number';
};
FilterGuards.isFloatArray = (argument) => {
  return (
    argument instanceof Array && argument.every((arg) => typeof arg === 'number' && !Number.isInteger(arg))
  );
};
FilterGuards.isBoolean = (argument) => {
  return typeof argument === 'boolean';
};
FilterGuards.isBooleanArray = (argument) => {
  return argument instanceof Array && argument.every((arg) => typeof arg === 'boolean');
};
FilterGuards.isDate = (argument) => {
  return argument instanceof Date;
};
FilterGuards.isDateArray = (argument) => {
  return argument instanceof Array && argument.every((arg) => arg instanceof Date);
};
FilterGuards.isGeoRange = (argument) => {
  const arg = argument;
  return arg.latitude !== undefined && arg.longitude !== undefined && arg.distance !== undefined;
};
class DataGuards {}
exports.DataGuards = DataGuards;
DataGuards.isText = (argument) => {
  return typeof argument === 'string';
};
DataGuards.isTextArray = (argument) => {
  return argument instanceof Array && argument.length > 0 && argument.every(DataGuards.isText);
};
DataGuards.isInt = (argument) => {
  return (
    typeof argument === 'number' &&
    Number.isInteger(argument) &&
    !Number.isNaN(argument) &&
    Number.isFinite(argument)
  );
};
DataGuards.isIntArray = (argument) => {
  return argument instanceof Array && argument.length > 0 && argument.every(DataGuards.isInt);
};
DataGuards.isFloat = (argument) => {
  return (
    typeof argument === 'number' &&
    !Number.isInteger(argument) &&
    !Number.isNaN(argument) &&
    Number.isFinite(argument)
  );
};
DataGuards.isFloatArray = (argument) => {
  return argument instanceof Array && argument.length > 0 && argument.every(DataGuards.isFloat);
};
DataGuards.isBoolean = (argument) => {
  return typeof argument === 'boolean';
};
DataGuards.isBooleanArray = (argument) => {
  return argument instanceof Array && argument.length > 0 && argument.every(DataGuards.isBoolean);
};
DataGuards.isDate = (argument) => {
  return argument instanceof Date;
};
DataGuards.isDateArray = (argument) => {
  return argument instanceof Array && argument.length > 0 && argument.every(DataGuards.isDate);
};
DataGuards.isGeoCoordinate = (argument) => {
  return (
    argument instanceof Object &&
    argument.latitude !== undefined &&
    argument.longitude !== undefined &&
    Object.keys(argument).length === 2
  );
};
DataGuards.isPhoneNumber = (argument) => {
  return (
    argument instanceof Object &&
    argument.number !== undefined &&
    (Object.keys(argument).length === 1 ||
      (Object.keys(argument).length === 2 && argument.defaultCountry !== undefined))
  );
};
DataGuards.isNested = (argument) => {
  return (
    argument instanceof Object &&
    !(argument instanceof Array) &&
    !DataGuards.isDate(argument) &&
    !DataGuards.isGeoCoordinate(argument) &&
    !DataGuards.isPhoneNumber(argument)
  );
};
DataGuards.isNestedArray = (argument) => {
  return argument instanceof Array && argument.length > 0 && argument.every(DataGuards.isNested);
};
DataGuards.isEmptyArray = (argument) => {
  return argument instanceof Array && argument.length === 0;
};
DataGuards.isDataObject = (obj) => {
  return (
    obj.id !== undefined ||
    obj.properties !== undefined ||
    obj.references !== undefined ||
    obj.vectors !== undefined
  );
};
class MetadataGuards {}
exports.MetadataGuards = MetadataGuards;
MetadataGuards.isKeys = (argument) => {
  return argument instanceof Array && argument.length > 0;
};
MetadataGuards.isAll = (argument) => {
  return argument === 'all';
};
MetadataGuards.isUndefined = (argument) => {
  return argument === undefined;
};
class Serialize {}
exports.Serialize = Serialize;
Serialize.isNamedVectors = (opts) => {
  return (
    Array.isArray(opts === null || opts === void 0 ? void 0 : opts.includeVector) ||
    (opts === null || opts === void 0 ? void 0 : opts.targetVector) !== undefined
  );
};
Serialize.common = (args) => {
  const out = {
    limit: args === null || args === void 0 ? void 0 : args.limit,
    offset: args === null || args === void 0 ? void 0 : args.offset,
    filters: (args === null || args === void 0 ? void 0 : args.filters)
      ? Serialize.filtersGRPC(args.filters)
      : undefined,
    properties:
      (args === null || args === void 0 ? void 0 : args.returnProperties) ||
      (args === null || args === void 0 ? void 0 : args.returnReferences)
        ? Serialize.queryProperties(args.returnProperties, args.returnReferences)
        : undefined,
    metadata: Serialize.metadata(
      args === null || args === void 0 ? void 0 : args.includeVector,
      args === null || args === void 0 ? void 0 : args.returnMetadata
    ),
  };
  if (args === null || args === void 0 ? void 0 : args.rerank) {
    out.rerank = Serialize.rerank(args.rerank);
  }
  return out;
};
Serialize.fetchObjects = (args) => {
  return Object.assign(Object.assign({}, Serialize.common(args)), {
    after: args === null || args === void 0 ? void 0 : args.after,
    sortBy: (args === null || args === void 0 ? void 0 : args.sort)
      ? Serialize.sortBy(args.sort.sorts)
      : undefined,
  });
};
Serialize.fetchObjectById = (args) => {
  return Object.assign(
    {},
    Serialize.common({
      filters: new classes_js_1.FilterId().equal(args.id),
      includeVector: args.includeVector,
      returnMetadata: ['creationTime', 'updateTime', 'isConsistent'],
      returnProperties: args.returnProperties,
      returnReferences: args.returnReferences,
    })
  );
};
Serialize.bm25 = (args) => {
  return Object.assign(Object.assign({}, Serialize.common(args)), {
    bm25Search: search_get_js_1.BM25.fromPartial({
      query: args.query,
      properties: args.queryProperties,
    }),
    autocut: args.autoLimit,
  });
};
Serialize.isHybridVectorSearch = (vector) => {
  return Array.isArray(vector);
};
Serialize.isHybridNearTextSearch = (vector) => {
  return (vector === null || vector === void 0 ? void 0 : vector.query) !== undefined;
};
Serialize.isHybridNearVectorSearch = (vector) => {
  return (vector === null || vector === void 0 ? void 0 : vector.vector) !== undefined;
};
Serialize.hybridVector = (vector) => {
  return Serialize.isHybridVectorSearch(vector) ? Serialize.vectorToBytes(vector) : undefined;
};
Serialize.hybridNearText = (vector) => {
  return Serialize.isHybridNearTextSearch(vector)
    ? Serialize.nearTextSearch(Object.assign(Object.assign({}, vector), { query: vector.query }))
    : undefined;
};
Serialize.hybridNearVector = (vector) => {
  return Serialize.isHybridNearVectorSearch(vector)
    ? search_get_js_1.NearVector.fromPartial({
        vectorBytes: Serialize.vectorToBytes(vector.vector),
      })
    : undefined;
};
Serialize.hybrid = (args) => {
  const fusionType = (fusionType) => {
    switch (fusionType) {
      case 'Ranked':
        return search_get_js_1.Hybrid_FusionType.FUSION_TYPE_RANKED;
      case 'RelativeScore':
        return search_get_js_1.Hybrid_FusionType.FUSION_TYPE_RELATIVE_SCORE;
      default:
        return search_get_js_1.Hybrid_FusionType.FUSION_TYPE_UNSPECIFIED;
    }
  };
  return Object.assign(Object.assign({}, Serialize.common(args)), {
    hybridSearch: search_get_js_1.Hybrid.fromPartial({
      query: args.query,
      alpha: args.alpha ? args.alpha : 0.5,
      properties: args.queryProperties,
      vectorBytes: Serialize.hybridVector(args.vector),
      fusionType: fusionType(args.fusionType),
      targetVectors: args.targetVector ? [args.targetVector] : undefined,
      nearText: Serialize.hybridNearText(args.vector),
      nearVector: Serialize.hybridNearVector(args.vector),
    }),
    autocut: args.autoLimit,
  });
};
Serialize.nearAudio = (args) => {
  return Object.assign(Object.assign({}, Serialize.common(args)), {
    nearAudio: search_get_js_1.NearAudioSearch.fromPartial({
      audio: args.audio,
      certainty: args.certainty,
      distance: args.distance,
      targetVectors: args.targetVector ? [args.targetVector] : undefined,
    }),
    autocut: args.autoLimit,
  });
};
Serialize.nearDepth = (args) => {
  return Object.assign(Object.assign({}, Serialize.common(args)), {
    nearDepth: search_get_js_1.NearDepthSearch.fromPartial({
      depth: args.depth,
      certainty: args.certainty,
      distance: args.distance,
      targetVectors: args.targetVector ? [args.targetVector] : undefined,
    }),
    autocut: args.autoLimit,
  });
};
Serialize.nearImage = (args) => {
  return Object.assign(Object.assign({}, Serialize.common(args)), {
    nearImage: search_get_js_1.NearImageSearch.fromPartial({
      image: args.image,
      certainty: args.certainty,
      distance: args.distance,
      targetVectors: args.targetVector ? [args.targetVector] : undefined,
    }),
    autocut: args.autoLimit,
  });
};
Serialize.nearIMU = (args) => {
  return Object.assign(Object.assign({}, Serialize.common(args)), {
    nearIMU: search_get_js_1.NearIMUSearch.fromPartial({
      imu: args.imu,
      certainty: args.certainty,
      distance: args.distance,
      targetVectors: args.targetVector ? [args.targetVector] : undefined,
    }),
    autocut: args.autoLimit,
  });
};
Serialize.nearObject = (args) => {
  return Object.assign(Object.assign({}, Serialize.common(args)), {
    nearObject: search_get_js_1.NearObject.fromPartial({
      id: args.id,
      certainty: args.certainty,
      distance: args.distance,
      targetVectors: args.targetVector ? [args.targetVector] : undefined,
    }),
    autocut: args.autoLimit,
  });
};
Serialize.nearTextSearch = (args) => {
  return search_get_js_1.NearTextSearch.fromPartial({
    query: typeof args.query === 'string' ? [args.query] : args.query,
    certainty: args.certainty,
    distance: args.distance,
    targetVectors: args.targetVector ? [args.targetVector] : undefined,
    moveAway: args.moveAway
      ? search_get_js_1.NearTextSearch_Move.fromPartial({
          concepts: args.moveAway.concepts,
          force: args.moveAway.force,
          uuids: args.moveAway.objects,
        })
      : undefined,
    moveTo: args.moveTo
      ? search_get_js_1.NearTextSearch_Move.fromPartial({
          concepts: args.moveTo.concepts,
          force: args.moveTo.force,
          uuids: args.moveTo.objects,
        })
      : undefined,
  });
};
Serialize.nearText = (args) => {
  return Object.assign(Object.assign({}, Serialize.common(args)), {
    nearText: Serialize.nearTextSearch(args),
    autocut: args.autoLimit,
  });
};
Serialize.nearThermal = (args) => {
  return Object.assign(Object.assign({}, Serialize.common(args)), {
    nearThermal: search_get_js_1.NearThermalSearch.fromPartial({
      thermal: args.thermal,
      certainty: args.certainty,
      distance: args.distance,
      targetVectors: args.targetVector ? [args.targetVector] : undefined,
    }),
    autocut: args.autoLimit,
  });
};
Serialize.vectorToBytes = (vector) => {
  return new Uint8Array(new Float32Array(vector).buffer);
};
Serialize.nearVectorSearch = (args) => {
  return search_get_js_1.NearVector.fromPartial({
    vectorBytes: Serialize.vectorToBytes(args.vector),
    certainty: args.certainty,
    distance: args.distance,
    targetVectors: args.targetVector ? [args.targetVector] : undefined,
  });
};
Serialize.nearVector = (args) => {
  return Object.assign(Object.assign({}, Serialize.common(args)), {
    nearVector: Serialize.nearVectorSearch(args),
    autocut: args.autoLimit,
  });
};
Serialize.nearVideo = (args) => {
  return Object.assign(Object.assign({}, Serialize.common(args)), {
    nearVideo: search_get_js_1.NearVideoSearch.fromPartial({
      video: args.video,
      certainty: args.certainty,
      distance: args.distance,
      targetVectors: args.targetVector ? [args.targetVector] : undefined,
    }),
    autocut: args.autoLimit,
  });
};
Serialize.filtersGRPC = (filters) => {
  const resolveFilters = (filters) => {
    var _a;
    const out = [];
    (_a = filters.filters) === null || _a === void 0
      ? void 0
      : _a.forEach((val) => out.push(Serialize.filtersGRPC(val)));
    return out;
  };
  const { value } = filters;
  switch (filters.operator) {
    case 'And':
      return base_js_1.Filters.fromPartial({
        operator: base_js_1.Filters_Operator.OPERATOR_AND,
        filters: resolveFilters(filters),
      });
    case 'Or':
      return base_js_1.Filters.fromPartial({
        operator: base_js_1.Filters_Operator.OPERATOR_OR,
        filters: resolveFilters(filters),
      });
    default:
      return base_js_1.Filters.fromPartial({
        operator: Serialize.operator(filters.operator),
        target: filters.target,
        valueText: FilterGuards.isText(value) ? value : undefined,
        valueTextArray: FilterGuards.isTextArray(value) ? { values: value } : undefined,
        valueInt: FilterGuards.isInt(value) ? value : undefined,
        valueIntArray: FilterGuards.isIntArray(value) ? { values: value } : undefined,
        valueNumber: FilterGuards.isFloat(value) ? value : undefined,
        valueNumberArray: FilterGuards.isFloatArray(value) ? { values: value } : undefined,
        valueBoolean: FilterGuards.isBoolean(value) ? value : undefined,
        valueBooleanArray: FilterGuards.isBooleanArray(value) ? { values: value } : undefined,
        valueGeo: FilterGuards.isGeoRange(value) ? value : undefined,
      });
  }
};
Serialize.filterTargetToREST = (target) => {
  if (target.property) {
    return [target.property];
  } else if (target.singleTarget) {
    throw new errors_js_1.WeaviateSerializationError(
      'Cannot use Filter.byRef() in the aggregate API currently. Instead use Filter.byRefMultiTarget() and specify the target collection explicitly.'
    );
  } else if (target.multiTarget) {
    if (target.multiTarget.target === undefined) {
      throw new errors_js_1.WeaviateSerializationError(
        `target of multiTarget filter was unexpectedly undefined: ${target}`
      );
    }
    return [
      target.multiTarget.on,
      target.multiTarget.targetCollection,
      ...Serialize.filterTargetToREST(target.multiTarget.target),
    ];
  } else if (target.count) {
    return [target.count.on];
  } else {
    return [];
  }
};
Serialize.filtersREST = (filters) => {
  var _a;
  const { value } = filters;
  if (filters.operator === 'And' || filters.operator === 'Or') {
    return {
      operator: filters.operator,
      operands: (_a = filters.filters) === null || _a === void 0 ? void 0 : _a.map(Serialize.filtersREST),
    };
  } else {
    if (filters.target === undefined) {
      throw new errors_js_1.WeaviateSerializationError(
        `target of filter was unexpectedly undefined: ${filters}`
      );
    }
    const out = {
      path: Serialize.filterTargetToREST(filters.target),
      operator: filters.operator,
    };
    if (FilterGuards.isText(value)) {
      return Object.assign(Object.assign({}, out), { valueText: value });
    } else if (FilterGuards.isTextArray(value)) {
      return Object.assign(Object.assign({}, out), { valueTextArray: value });
    } else if (FilterGuards.isInt(value)) {
      return Object.assign(Object.assign({}, out), { valueInt: value });
    } else if (FilterGuards.isIntArray(value)) {
      return Object.assign(Object.assign({}, out), { valueIntArray: value });
    } else if (FilterGuards.isBoolean(value)) {
      return Object.assign(Object.assign({}, out), { valueBoolean: value });
    } else if (FilterGuards.isBooleanArray(value)) {
      return Object.assign(Object.assign({}, out), { valueBooleanArray: value });
    } else if (FilterGuards.isFloat(value)) {
      return Object.assign(Object.assign({}, out), { valueNumber: value });
    } else if (FilterGuards.isFloatArray(value)) {
      return Object.assign(Object.assign({}, out), { valueNumberArray: value });
    } else if (FilterGuards.isDate(value)) {
      return Object.assign(Object.assign({}, out), { valueDate: value.toISOString() });
    } else if (FilterGuards.isDateArray(value)) {
      return Object.assign(Object.assign({}, out), { valueDateArray: value.map((v) => v.toISOString()) });
    } else if (FilterGuards.isGeoRange(value)) {
      return Object.assign(Object.assign({}, out), {
        valueGeoRange: {
          geoCoordinates: {
            latitude: value.latitude,
            longitude: value.longitude,
          },
          distance: {
            max: value.distance,
          },
        },
      });
    } else {
      throw new errors_js_1.WeaviateInvalidInputError('Invalid filter value type');
    }
  }
};
Serialize.operator = (operator) => {
  switch (operator) {
    case 'Equal':
      return base_js_1.Filters_Operator.OPERATOR_EQUAL;
    case 'NotEqual':
      return base_js_1.Filters_Operator.OPERATOR_NOT_EQUAL;
    case 'ContainsAny':
      return base_js_1.Filters_Operator.OPERATOR_CONTAINS_ANY;
    case 'ContainsAll':
      return base_js_1.Filters_Operator.OPERATOR_CONTAINS_ALL;
    case 'GreaterThan':
      return base_js_1.Filters_Operator.OPERATOR_GREATER_THAN;
    case 'GreaterThanEqual':
      return base_js_1.Filters_Operator.OPERATOR_GREATER_THAN_EQUAL;
    case 'LessThan':
      return base_js_1.Filters_Operator.OPERATOR_LESS_THAN;
    case 'LessThanEqual':
      return base_js_1.Filters_Operator.OPERATOR_LESS_THAN_EQUAL;
    case 'Like':
      return base_js_1.Filters_Operator.OPERATOR_LIKE;
    case 'WithinGeoRange':
      return base_js_1.Filters_Operator.OPERATOR_WITHIN_GEO_RANGE;
    case 'IsNull':
      return base_js_1.Filters_Operator.OPERATOR_IS_NULL;
    default:
      return base_js_1.Filters_Operator.OPERATOR_UNSPECIFIED;
  }
};
Serialize.queryProperties = (properties, references) => {
  const nonRefProperties =
    properties === null || properties === void 0
      ? void 0
      : properties.filter((property) => typeof property === 'string');
  const refProperties = references;
  const objectProperties =
    properties === null || properties === void 0
      ? void 0
      : properties.filter((property) => typeof property === 'object');
  const resolveObjectProperty = (property) => {
    const objProps = property.properties.filter((property) => typeof property !== 'string'); // cannot get types to work currently :(
    return {
      propName: property.name,
      primitiveProperties: property.properties.filter((property) => typeof property === 'string'),
      objectProperties: objProps.map(resolveObjectProperty),
    };
  };
  return {
    nonRefProperties: nonRefProperties === undefined ? [] : nonRefProperties,
    returnAllNonrefProperties: nonRefProperties === undefined,
    refProperties: refProperties
      ? refProperties.map((property) => {
          return {
            referenceProperty: property.linkOn,
            properties: Serialize.queryProperties(property.returnProperties),
            metadata: Serialize.metadata(property.includeVector, property.returnMetadata),
            targetCollection: property.targetCollection ? property.targetCollection : '',
          };
        })
      : [],
    objectProperties: objectProperties
      ? objectProperties.map((property) => {
          const objProps = property.properties.filter((property) => typeof property !== 'string'); // cannot get types to work currently :(
          return {
            propName: property.name,
            primitiveProperties: property.properties.filter((property) => typeof property === 'string'),
            objectProperties: objProps.map(resolveObjectProperty),
          };
        })
      : [],
  };
};
Serialize.metadata = (includeVector, metadata) => {
  const out = {
    uuid: true,
    vector: typeof includeVector === 'boolean' ? includeVector : false,
    vectors: Array.isArray(includeVector) ? includeVector : [],
  };
  if (MetadataGuards.isAll(metadata)) {
    return Object.assign(Object.assign({}, out), {
      creationTimeUnix: true,
      lastUpdateTimeUnix: true,
      distance: true,
      certainty: true,
      score: true,
      explainScore: true,
      isConsistent: true,
    });
  }
  metadata === null || metadata === void 0
    ? void 0
    : metadata.forEach((key) => {
        let weaviateKey;
        if (key === 'creationTime') {
          weaviateKey = 'creationTimeUnix';
        } else if (key === 'updateTime') {
          weaviateKey = 'lastUpdateTimeUnix';
        } else {
          weaviateKey = key;
        }
        out[weaviateKey] = true;
      });
  return search_get_js_1.MetadataRequest.fromPartial(out);
};
Serialize.sortBy = (sort) => {
  return sort.map((sort) => {
    return {
      ascending: !!sort.ascending,
      path: [sort.property],
    };
  });
};
Serialize.rerank = (rerank) => {
  return search_get_js_1.Rerank.fromPartial({
    property: rerank.property,
    query: rerank.query,
  });
};
Serialize.generative = (generative) => {
  return search_get_js_1.GenerativeSearch.fromPartial({
    singleResponsePrompt: generative === null || generative === void 0 ? void 0 : generative.singlePrompt,
    groupedResponseTask: generative === null || generative === void 0 ? void 0 : generative.groupedTask,
    groupedProperties: generative === null || generative === void 0 ? void 0 : generative.groupedProperties,
  });
};
Serialize.groupBy = (groupBy) => {
  return search_get_js_1.GroupBy.fromPartial({
    path: (groupBy === null || groupBy === void 0 ? void 0 : groupBy.property)
      ? [groupBy.property]
      : undefined,
    numberOfGroups: groupBy === null || groupBy === void 0 ? void 0 : groupBy.numberOfGroups,
    objectsPerGroup: groupBy === null || groupBy === void 0 ? void 0 : groupBy.objectsPerGroup,
  });
};
Serialize.isGroupBy = (args) => {
  if (args === undefined) return false;
  return args.groupBy !== undefined;
};
Serialize.restProperties = (properties, references) => {
  const parsedProperties = {};
  Object.keys(properties).forEach((key) => {
    const value = properties[key];
    if (DataGuards.isDate(value)) {
      parsedProperties[key] = value.toISOString();
    } else if (DataGuards.isDateArray(value)) {
      parsedProperties[key] = value.map((v) => v.toISOString());
    } else if (DataGuards.isPhoneNumber(value)) {
      parsedProperties[key] = {
        input: value.number,
        defaultCountry: value.defaultCountry,
      };
    } else if (DataGuards.isNestedArray(value)) {
      parsedProperties[key] = value.map((v) => Serialize.restProperties(v));
    } else if (DataGuards.isNested(value)) {
      parsedProperties[key] = Serialize.restProperties(value);
    } else {
      parsedProperties[key] = value;
    }
  });
  if (!references) return parsedProperties;
  for (const [key, value] of Object.entries(references)) {
    if (classes_js_2.ReferenceGuards.isReferenceManager(value)) {
      parsedProperties[key] = value.toBeaconObjs();
    } else if (classes_js_2.ReferenceGuards.isUuid(value)) {
      parsedProperties[key] = [(0, utils_js_1.uuidToBeacon)(value)];
    } else if (classes_js_2.ReferenceGuards.isMultiTarget(value)) {
      parsedProperties[key] =
        typeof value.uuids === 'string'
          ? [(0, utils_js_1.uuidToBeacon)(value.uuids, value.targetCollection)]
          : value.uuids.map((uuid) => (0, utils_js_1.uuidToBeacon)(uuid, value.targetCollection));
    } else {
      let out = [];
      value.forEach((v) => {
        if (classes_js_2.ReferenceGuards.isReferenceManager(v)) {
          out = out.concat(v.toBeaconObjs());
        } else if (classes_js_2.ReferenceGuards.isUuid(v)) {
          out.push((0, utils_js_1.uuidToBeacon)(v));
        } else {
          out = out.concat(
            (classes_js_2.ReferenceGuards.isUuid(v.uuids) ? [v.uuids] : v.uuids).map((uuid) =>
              (0, utils_js_1.uuidToBeacon)(uuid, v.targetCollection)
            )
          );
        }
      });
      parsedProperties[key] = out;
    }
  }
  return parsedProperties;
};
Serialize.batchProperties = (properties, references) => {
  const multiTarget = [];
  const singleTarget = [];
  const nonRefProperties = {};
  const emptyArray = [];
  const boolArray = [];
  const textArray = [];
  const intArray = [];
  const floatArray = [];
  const objectProperties = [];
  const objectArrayProperties = [];
  const resolveProps = (key, value) => {
    if (DataGuards.isEmptyArray(value)) {
      emptyArray.push(key);
    } else if (DataGuards.isBooleanArray(value)) {
      boolArray.push({
        propName: key,
        values: value,
      });
    } else if (DataGuards.isDateArray(value)) {
      textArray.push({
        propName: key,
        values: value.map((v) => v.toISOString()),
      });
    } else if (DataGuards.isTextArray(value)) {
      textArray.push({
        propName: key,
        values: value,
      });
    } else if (DataGuards.isIntArray(value)) {
      intArray.push({
        propName: key,
        values: value,
      });
    } else if (DataGuards.isFloatArray(value)) {
      floatArray.push({
        propName: key,
        values: [],
        valuesBytes: new Uint8Array(new Float64Array(value).buffer), // is double in proto => f64 in go
      });
    } else if (DataGuards.isDate(value)) {
      nonRefProperties[key] = value.toISOString();
    } else if (DataGuards.isPhoneNumber(value)) {
      nonRefProperties[key] = {
        input: value.number,
        defaultCountry: value.defaultCountry,
      };
    } else if (DataGuards.isGeoCoordinate(value)) {
      nonRefProperties[key] = value;
    } else if (DataGuards.isNestedArray(value)) {
      objectArrayProperties.push({
        propName: key,
        values: value.map((v) => base_js_1.ObjectPropertiesValue.fromPartial(Serialize.batchProperties(v))),
      });
    } else if (DataGuards.isNested(value)) {
      const parsed = Serialize.batchProperties(value);
      objectProperties.push({
        propName: key,
        value: base_js_1.ObjectPropertiesValue.fromPartial(parsed),
      });
    } else {
      nonRefProperties[key] = value;
    }
  };
  const resolveRefs = (key, value) => {
    if (classes_js_2.ReferenceGuards.isReferenceManager(value)) {
      if (value.isMultiTarget()) {
        multiTarget.push({
          propName: key,
          targetCollection: value.targetCollection,
          uuids: value.toBeaconStrings(),
        });
      } else {
        singleTarget.push({
          propName: key,
          uuids: value.toBeaconStrings(),
        });
      }
    } else if (classes_js_2.ReferenceGuards.isUuid(value)) {
      singleTarget.push({
        propName: key,
        uuids: [value],
      });
    } else if (classes_js_2.ReferenceGuards.isMultiTarget(value)) {
      multiTarget.push({
        propName: key,
        targetCollection: value.targetCollection,
        uuids: typeof value.uuids === 'string' ? [value.uuids] : value.uuids,
      });
    } else {
      value.forEach((v) => resolveRefs(key, v));
    }
  };
  if (properties) {
    Object.entries(properties).forEach(([key, value]) => resolveProps(key, value));
  }
  if (references) {
    Object.entries(references).forEach(([key, value]) => resolveRefs(key, value));
  }
  return {
    nonRefProperties: nonRefProperties,
    multiTargetRefProps: multiTarget,
    singleTargetRefProps: singleTarget,
    textArrayProperties: textArray,
    intArrayProperties: intArray,
    numberArrayProperties: floatArray,
    booleanArrayProperties: boolArray,
    objectProperties: objectProperties,
    objectArrayProperties: objectArrayProperties,
    emptyListProps: emptyArray,
  };
};
Serialize.batchObjects = (collection, objects, usesNamedVectors, tenant) => {
  const objs = [];
  const batch = [];
  const iterate = (index) => {
    // This allows the potentially CPU-intensive work to be done in chunks
    // releasing control to the event loop after every object so that other
    // events can be processed without blocking completely.
    if (index < objects.length) {
      setTimeout(() => iterate(index + 1));
    } else {
      return;
    }
    const object = objects[index];
    const obj = DataGuards.isDataObject(object)
      ? object
      : { id: undefined, properties: object, references: undefined, vectors: undefined };
    let vectorBytes;
    let vectors;
    if (obj.vectors !== undefined && !Array.isArray(obj.vectors)) {
      vectors = Object.entries(obj.vectors).map(([k, v]) =>
        base_js_1.Vectors.fromPartial({
          vectorBytes: Serialize.vectorToBytes(v),
          name: k,
        })
      );
    } else if (Array.isArray(obj.vectors) && usesNamedVectors) {
      vectors = [
        base_js_1.Vectors.fromPartial({
          vectorBytes: Serialize.vectorToBytes(obj.vectors),
          name: 'default',
        }),
      ];
    } else if (obj.vectors !== undefined) {
      vectorBytes = Serialize.vectorToBytes(obj.vectors);
    }
    objs.push(
      batch_js_1.BatchObject.fromPartial({
        collection: collection,
        properties: Serialize.batchProperties(obj.properties, obj.references),
        tenant: tenant,
        uuid: obj.id ? obj.id : (0, uuid_1.v4)(),
        vectorBytes,
        vectors,
      })
    );
    batch.push(Object.assign(Object.assign({}, obj), { collection: collection, tenant: tenant }));
  };
  const waitFor = () => {
    const poll = (resolve) => {
      if (objs.length < objects.length) {
        setTimeout(() => poll(resolve), 500);
      } else {
        resolve(null);
      }
    };
    return new Promise(poll);
  };
  iterate(0);
  return waitFor().then(() => {
    return { batch: batch, mapped: objs };
  });
};
