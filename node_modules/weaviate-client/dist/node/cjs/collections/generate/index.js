'use strict';
var __awaiter =
  (this && this.__awaiter) ||
  function (thisArg, _arguments, P, generator) {
    function adopt(value) {
      return value instanceof P
        ? value
        : new P(function (resolve) {
            resolve(value);
          });
    }
    return new (P || (P = Promise))(function (resolve, reject) {
      function fulfilled(value) {
        try {
          step(generator.next(value));
        } catch (e) {
          reject(e);
        }
      }
      function rejected(value) {
        try {
          step(generator['throw'](value));
        } catch (e) {
          reject(e);
        }
      }
      function step(result) {
        result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
      }
      step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
  };
Object.defineProperty(exports, '__esModule', { value: true });
const errors_js_1 = require('../../errors.js');
const index_js_1 = require('../deserialize/index.js');
const index_js_2 = require('../serialize/index.js');
class GenerateManager {
  constructor(connection, name, dbVersionSupport, consistencyLevel, tenant) {
    this.checkSupportForNamedVectors = (opts) =>
      __awaiter(this, void 0, void 0, function* () {
        if (!index_js_2.Serialize.isNamedVectors(opts)) return;
        const check = yield this.dbVersionSupport.supportsNamedVectors();
        if (!check.supports) throw new errors_js_1.WeaviateUnsupportedFeatureError(check.message);
      });
    this.checkSupportForBm25AndHybridGroupByQueries = (query, opts) =>
      __awaiter(this, void 0, void 0, function* () {
        if (!index_js_2.Serialize.isGroupBy(opts)) return;
        const check = yield this.dbVersionSupport.supportsBm25AndHybridGroupByQueries();
        if (!check.supports) throw new errors_js_1.WeaviateUnsupportedFeatureError(check.message(query));
      });
    this.connection = connection;
    this.name = name;
    this.dbVersionSupport = dbVersionSupport;
    this.consistencyLevel = consistencyLevel;
    this.tenant = tenant;
  }
  static use(connection, name, dbVersionSupport, consistencyLevel, tenant) {
    return new GenerateManager(connection, name, dbVersionSupport, consistencyLevel, tenant);
  }
  parseReply(reply) {
    return __awaiter(this, void 0, void 0, function* () {
      const deserialize = yield index_js_1.Deserialize.use(this.dbVersionSupport);
      return deserialize.generate(reply);
    });
  }
  parseGroupByReply(opts, reply) {
    return __awaiter(this, void 0, void 0, function* () {
      const deserialize = yield index_js_1.Deserialize.use(this.dbVersionSupport);
      return index_js_2.Serialize.isGroupBy(opts)
        ? deserialize.generateGroupBy(reply)
        : deserialize.generate(reply);
    });
  }
  fetchObjects(generate, opts) {
    return this.checkSupportForNamedVectors(opts)
      .then(() => this.connection.search(this.name, this.consistencyLevel, this.tenant))
      .then((search) =>
        search.withFetch(
          Object.assign(Object.assign({}, index_js_2.Serialize.fetchObjects(opts)), {
            generative: index_js_2.Serialize.generative(generate),
          })
        )
      )
      .then((reply) => this.parseReply(reply));
  }
  bm25(query, generate, opts) {
    return Promise.all([
      this.checkSupportForNamedVectors(opts),
      this.checkSupportForBm25AndHybridGroupByQueries('Bm25', opts),
    ])
      .then(() => this.connection.search(this.name, this.consistencyLevel, this.tenant))
      .then((search) =>
        search.withBm25(
          Object.assign(Object.assign({}, index_js_2.Serialize.bm25(Object.assign({ query }, opts))), {
            generative: index_js_2.Serialize.generative(generate),
            groupBy: index_js_2.Serialize.isGroupBy(opts)
              ? index_js_2.Serialize.groupBy(opts.groupBy)
              : undefined,
          })
        )
      )
      .then((reply) => this.parseGroupByReply(opts, reply));
  }
  hybrid(query, generate, opts) {
    return Promise.all([
      this.checkSupportForNamedVectors(opts),
      this.checkSupportForBm25AndHybridGroupByQueries('Bm25', opts),
    ])
      .then(() => this.connection.search(this.name, this.consistencyLevel, this.tenant))
      .then((search) =>
        search.withHybrid(
          Object.assign(Object.assign({}, index_js_2.Serialize.hybrid(Object.assign({ query }, opts))), {
            generative: index_js_2.Serialize.generative(generate),
            groupBy: index_js_2.Serialize.isGroupBy(opts)
              ? index_js_2.Serialize.groupBy(opts.groupBy)
              : undefined,
          })
        )
      )
      .then((reply) => this.parseGroupByReply(opts, reply));
  }
  nearImage(image, generate, opts) {
    return this.checkSupportForNamedVectors(opts)
      .then(() => this.connection.search(this.name, this.consistencyLevel, this.tenant))
      .then((search) =>
        search.withNearImage(
          Object.assign(
            Object.assign({}, index_js_2.Serialize.nearImage(Object.assign({ image }, opts ? opts : {}))),
            {
              generative: index_js_2.Serialize.generative(generate),
              groupBy: index_js_2.Serialize.isGroupBy(opts)
                ? index_js_2.Serialize.groupBy(opts.groupBy)
                : undefined,
            }
          )
        )
      )
      .then((reply) => this.parseGroupByReply(opts, reply));
  }
  nearObject(id, generate, opts) {
    return this.checkSupportForNamedVectors(opts)
      .then(() => this.connection.search(this.name, this.consistencyLevel, this.tenant))
      .then((search) =>
        search.withNearObject(
          Object.assign(
            Object.assign({}, index_js_2.Serialize.nearObject(Object.assign({ id }, opts ? opts : {}))),
            {
              generative: index_js_2.Serialize.generative(generate),
              groupBy: index_js_2.Serialize.isGroupBy(opts)
                ? index_js_2.Serialize.groupBy(opts.groupBy)
                : undefined,
            }
          )
        )
      )
      .then((reply) => this.parseGroupByReply(opts, reply));
  }
  nearText(query, generate, opts) {
    return this.checkSupportForNamedVectors(opts)
      .then(() => this.connection.search(this.name, this.consistencyLevel, this.tenant))
      .then((search) =>
        search.withNearText(
          Object.assign(
            Object.assign({}, index_js_2.Serialize.nearText(Object.assign({ query }, opts ? opts : {}))),
            {
              generative: index_js_2.Serialize.generative(generate),
              groupBy: index_js_2.Serialize.isGroupBy(opts)
                ? index_js_2.Serialize.groupBy(opts.groupBy)
                : undefined,
            }
          )
        )
      )
      .then((reply) => this.parseGroupByReply(opts, reply));
  }
  nearVector(vector, generate, opts) {
    return this.checkSupportForNamedVectors(opts)
      .then(() => this.connection.search(this.name, this.consistencyLevel, this.tenant))
      .then((search) =>
        search.withNearVector(
          Object.assign(
            Object.assign({}, index_js_2.Serialize.nearVector(Object.assign({ vector }, opts ? opts : {}))),
            {
              generative: index_js_2.Serialize.generative(generate),
              groupBy: index_js_2.Serialize.isGroupBy(opts)
                ? index_js_2.Serialize.groupBy(opts.groupBy)
                : undefined,
            }
          )
        )
      )
      .then((reply) => this.parseGroupByReply(opts, reply));
  }
  nearMedia(media, type, generate, opts) {
    return this.checkSupportForNamedVectors(opts)
      .then(() => this.connection.search(this.name, this.consistencyLevel, this.tenant))
      .then((search) => {
        let reply;
        const generative = index_js_2.Serialize.generative(generate);
        const groupBy = index_js_2.Serialize.isGroupBy(opts)
          ? index_js_2.Serialize.groupBy(opts.groupBy)
          : undefined;
        switch (type) {
          case 'audio':
            reply = search.withNearAudio(
              Object.assign(
                Object.assign(
                  {},
                  index_js_2.Serialize.nearAudio(Object.assign({ audio: media }, opts ? opts : {}))
                ),
                { generative, groupBy }
              )
            );
            break;
          case 'depth':
            reply = search.withNearDepth(
              Object.assign(
                Object.assign(
                  {},
                  index_js_2.Serialize.nearDepth(Object.assign({ depth: media }, opts ? opts : {}))
                ),
                { generative, groupBy }
              )
            );
            break;
          case 'image':
            reply = search.withNearImage(
              Object.assign(
                Object.assign(
                  {},
                  index_js_2.Serialize.nearImage(Object.assign({ image: media }, opts ? opts : {}))
                ),
                { generative, groupBy }
              )
            );
            break;
          case 'imu':
            reply = search.withNearIMU(
              Object.assign(
                Object.assign(
                  {},
                  index_js_2.Serialize.nearIMU(Object.assign({ imu: media }, opts ? opts : {}))
                ),
                { generative, groupBy }
              )
            );
            break;
          case 'thermal':
            reply = search.withNearThermal(
              Object.assign(
                Object.assign(
                  {},
                  index_js_2.Serialize.nearThermal(Object.assign({ thermal: media }, opts ? opts : {}))
                ),
                { generative, groupBy }
              )
            );
            break;
          case 'video':
            reply = search.withNearVideo(
              Object.assign(
                Object.assign(
                  {},
                  index_js_2.Serialize.nearVideo(Object.assign({ video: media }, opts ? opts : {}))
                ),
                { generative, groupBy }
              )
            );
            break;
          default:
            throw new errors_js_1.WeaviateInvalidInputError(`Invalid media type: ${type}`);
        }
        return reply;
      })
      .then((reply) => this.parseGroupByReply(opts, reply));
  }
}
exports.default = GenerateManager.use;
